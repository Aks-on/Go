package main

import "fmt"

func main() {
	//Есть срез данных. Куча сортированная как бинарное дерево
	//родительский узел >= обоих дочерних
	a := []int{0, 2, 1, 3, 15, 4, 19, 42, 8, 18}

	// Чтобы добавить элемент и разместить в нужном месте бинарного дерева:
	x := 7
	a = append(a, x)
	index := len(a) - 1
	// Просеивание вверх
	// Пока есть родитель и элемент меньше родителя, своп
	for index-1 >= 0 && a[index] < a[(index-1)/2] {
		a[index], a[(index-1)/2] = a[(index-1)/2], a[index]
		index = (index - 1) / 2
	}
	fmt.Println(a)

	// Минимальный элемент в дереве находится в корневом узле. a[0]

	// Чтобы убрать мин. элемент, меняем 0-ой элемент и последний
	a[0], a[len(a)-1] = a[len(a)-1], a[0]
	a = a[:len(a)-1]
	// Потом выбираем меньшего из детей и меняем их местами (новый нулевой элемент и меньшее дитя)
	// Потом снова своп с меньшим ребёнком, если такой есть
	//Просеивание вниз
	index = 0
	// Пока есть хотя бы 1 ребёнок и элемент меньше родителя, своп
	for index*2+1 < len(a) {
		j := 2*index + 1
		//Если есть второй ребёнок и он меньше, чем первый, запоминаем его индекс как меньшего дитя
		if j+1 < len(a) && a[j] > a[j+1] {
			j++
		}
		// Если наш элемент меньше меньшего ребёнка, то выходим, если нет - своп
		if a[index] <= a[j] {
			break
		} else {
			a[index], a[j] = a[j], a[index]
			index = j
		}
	}

}
